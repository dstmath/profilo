// Copyright 2004-present Facebook. All Rights Reserved.
// Generated by: //native/museum/run_codegen.sh
// This is generated code -- do not modify manually.

// @{{!.}}generated SignedSource<<00000000000000000000000000000000>>
// @model md5 {{{modelHash}}}

{{!
This is the model for the mappings between Museum's headers and ART's method implementations.
This will be used to generate "implementations" of the header-declared methods and globals,
which in reality will simply look up the actual implementations in libart.so and delegate
calls to the real versions.

YAML reference: http://www.yaml.org/refcard.html

=== Schema ===
(file)
  library           => string               Required        Which library these symbols live in. Must correspond
                                                            to a library exposed by libs.h
  headers           => string[]             Required        List of headers to include in generated cpp
  namespaces        => ns_spec[]            Optional        Root of definition hierarchy
  modelHash         => string               Generated       Autogenerated in preprocessor. Do not set.

(ns_spec)
  nsName            => string[]             Optional        Namespace of the classes. String array where each
                                                            element is a nested namespace.
  classes           => class_spec[]         Required        Root of definition hierarchy
  hasNsName         => boolean              Generated       Autogenerated in preprocessor. Do not set.

(class_spec)
  className         => string               Nullable        Class name for subsequent set of symbols
  symbols           => symbol_spec[]        Required        Set of symbols defined by particular class
  instantiate       => boolean              optional        If true, explicitly instantiate the template

(symbol_spec)
  symbolName        => string               Required        Name of the symbol (method or static field)
  params            => string[]             Optional        Omit if no-param method, dtor, or static field
  returnType        => string               Optional        Omit if ctor. Use "void" if void method.
  mangledNames      => string[]             Required        List of raw mangled names in DSO.
  cvFlags           => string               Optional        const/volatile modifiers of method
  exceptFlags       => string               Optional        Exception flags of method
  isStaticVar       => boolean              Optional        true if static field or global
  isStaticMethod    => boolean              optional        true if static method
  skipMethodWrap    => boolean              Optional        true to skip method-wrapping check (you don't need
                                                              this.. mostly a workaround for Runtime::instance_
                                                              that doesn't quite perfectly fit the pattern)
}}

{{#headers}}
#include <{{{.}}}>
{{/headers}}

#include <museum/libs.h>

namespace facebook { namespace museum { namespace MUSEUM_VERSION {

{{#namespaces}}
{{#classes}}
{{#instantiate}}template class {{#nsName}}{{{name}}}::{{/nsName}}{{{className}}};{{/instantiate}}
{{#symbols}}
{{#conditional}}#if {{{.}}}{{/conditional}}
namespace {{{library}}} { namespace lookups {
  template<typename T>
  T* lookup_{{#mangledNames}}_{{{.}}}{{/mangledNames}}() {
    static auto const symbol = ::facebook::{{{library}}}().get_symbol<T>({
      {{#mangledNames}}"{{{.}}}",{{/mangledNames}}
    });
    return symbol;
  }
} } // namespace {{{library}}}::lookups
{{#nsName}}{{#inline}}inline {{/inline}}namespace {{{name}}} { {{/nsName}}{{^nsName}}extern "C" { {{/nsName}}
{{#isStaticVar}}{{^skipMethodWrap}}#ifdef {{{symbolName}}}
  #undef {{{symbolName}}}
#else
  #error "{{{symbolName}}} is not method-wrapped and will not be proxied correctly"
#endif{{/skipMethodWrap}}{{/isStaticVar}}
  {{#instantiate}}template<>{{/instantiate}}
  {{{returnType}}}{{#isStaticVar}}&{{/isStaticVar}} {{#className}}{{{.}}}::{{/className}}{{{symbolName}}}({{#params}}{{{type}}} p{{{idx}}}, {{/params}}) {{{cvFlags}}} {{{exceptFlags}}} {
    {{#returnType}}return{{#isStaticVar}} *{{/isStaticVar}}{{/returnType}}
      ::facebook::museum::MUSEUM_VERSION::{{{library}}}::lookups::lookup_{{#mangledNames}}_{{{.}}}{{/mangledNames}}
      <{{{returnType}}}{{^returnType}}void{{/returnType}}
        {{^isStaticVar}}({{^isStaticMethod}}{{#className}}{{{.}}} {{{cvFlags}}}*, {{/className}}{{/isStaticMethod}}{{#params}}{{{type}}}, {{/params}}){{/isStaticVar}}>()
      {{^isStaticVar}}({{^isStaticMethod}}{{#className}}this, {{/className}}{{/isStaticMethod}}{{#params}}p{{{idx}}}, {{/params}}){{/isStaticVar}};
  }
{{#nsName}}} {{/nsName}}{{#hasNsName}}// namespace {{/hasNsName}}{{#nsName}}{{{name}}}::{{/nsName}}{{^nsName}} } // extern "C"{{/nsName}}
{{#conditional}}#endif{{/conditional}}
{{/symbols}}
{{/classes}}
{{/namespaces}}

namespace {{{library}}} {
  void preinitSymbols() {
    {{#namespaces}}
    {{#hasNsName}}using namespace ::facebook::museum::MUSEUM_VERSION{{#nsName}}::{{{name}}}{{/nsName}};{{/hasNsName}}
    {{#classes}}{{#symbols}}
    {{#conditional}}#if {{{.}}}{{/conditional}}
      ::facebook::museum::MUSEUM_VERSION::{{{library}}}::lookups::lookup_{{#mangledNames}}_{{{.}}}{{/mangledNames}}
        <{{{returnType}}}{{^returnType}}void{{/returnType}}
          {{^isStaticVar}}({{^isStaticMethod}}{{#className}}{{{.}}} {{{cvFlags}}}*, {{/className}}{{/isStaticMethod}}{{#params}}{{{type}}}, {{/params}}){{/isStaticVar}}>();
    {{#conditional}}#endif{{/conditional}}
    {{/symbols}}{{/classes}}
    {{/namespaces}}
  }
} // namespace {{{library}}}

} } } // namespace facebook::museum::MUSEUM_VERSION
