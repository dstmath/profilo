// Copyright 2004-present Facebook. All Rights Reserved.
// Generated by: //native/museum/run_codegen.sh
// This is generated code -- do not modify manually.

// @generated SignedSource<<d29bf2774af2f3ea1ff3e8c33cc51dcb>>
// @model md5 d29b1a403a21e2f8ff5302de9232d7fd


#include <museum/7.0.0/art/runtime/base/mutex.h>
#include <museum/7.0.0/art/runtime/runtime.h>
#include <museum/7.0.0/art/runtime/thread.h>
#include <new>

#include <museum/libs.h>

namespace facebook { namespace museum { namespace MUSEUM_VERSION {



namespace libart { namespace lookups {
  template<typename T>
  T* lookup___ZN3art5Locks13mutator_lock_E() {
    static auto const symbol = ::facebook::libart().get_symbol<T>({
      "_ZN3art5Locks13mutator_lock_E",
    });
    return symbol;
  }
} } // namespace libart::lookups
namespace art { 
#ifdef mutator_lock_
  #undef mutator_lock_
#else
  #error "mutator_lock_ is not method-wrapped and will not be proxied correctly"
#endif
  
  MutatorMutex*& Locks::mutator_lock_()   {
    return *
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art5Locks13mutator_lock_E
      <MutatorMutex*
        >()
      ;
  }
} // namespace art::


namespace libart { namespace lookups {
  template<typename T>
  T* lookup___ZN3art5Locks26thread_suspend_count_lock_E() {
    static auto const symbol = ::facebook::libart().get_symbol<T>({
      "_ZN3art5Locks26thread_suspend_count_lock_E",
    });
    return symbol;
  }
} } // namespace libart::lookups
namespace art { 
#ifdef thread_suspend_count_lock_
  #undef thread_suspend_count_lock_
#else
  #error "thread_suspend_count_lock_ is not method-wrapped and will not be proxied correctly"
#endif
  
  Mutex*& Locks::thread_suspend_count_lock_()   {
    return *
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art5Locks26thread_suspend_count_lock_E
      <Mutex*
        >()
      ;
  }
} // namespace art::



namespace libart { namespace lookups {
  template<typename T>
  T* lookup___ZN3art7Runtime9instance_E() {
    static auto const symbol = ::facebook::libart().get_symbol<T>({
      "_ZN3art7Runtime9instance_E",
    });
    return symbol;
  }
} } // namespace libart::lookups
namespace art { 

  
  Runtime*& Runtime::instance_()   {
    return *
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art7Runtime9instance_E
      <Runtime*
        >()
      ;
  }
} // namespace art::



namespace libart { namespace lookups {
  template<typename T>
  T* lookup___ZN3art6Thread12resume_cond_E() {
    static auto const symbol = ::facebook::libart().get_symbol<T>({
      "_ZN3art6Thread12resume_cond_E",
    });
    return symbol;
  }
} } // namespace libart::lookups
namespace art { 
#ifdef resume_cond_
  #undef resume_cond_
#else
  #error "resume_cond_ is not method-wrapped and will not be proxied correctly"
#endif
  
  ConditionVariable*& Thread::resume_cond_()   {
    return *
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art6Thread12resume_cond_E
      <ConditionVariable*
        >()
      ;
  }
} // namespace art::


namespace libart { namespace lookups {
  template<typename T>
  T* lookup___ZN3art6Thread11is_started_E() {
    static auto const symbol = ::facebook::libart().get_symbol<T>({
      "_ZN3art6Thread11is_started_E",
    });
    return symbol;
  }
} } // namespace libart::lookups
namespace art { 
#ifdef is_started_
  #undef is_started_
#else
  #error "is_started_ is not method-wrapped and will not be proxied correctly"
#endif
  
  bool& Thread::is_started_()   {
    return *
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art6Thread11is_started_E
      <bool
        >()
      ;
  }
} // namespace art::


namespace libart { namespace lookups {
  template<typename T>
  T* lookup___ZN3art6Thread17pthread_key_self_E() {
    static auto const symbol = ::facebook::libart().get_symbol<T>({
      "_ZN3art6Thread17pthread_key_self_E",
    });
    return symbol;
  }
} } // namespace libart::lookups
namespace art { 
#ifdef pthread_key_self_
  #undef pthread_key_self_
#else
  #error "pthread_key_self_ is not method-wrapped and will not be proxied correctly"
#endif
  
  pthread_key_t& Thread::pthread_key_self_()   {
    return *
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art6Thread17pthread_key_self_E
      <pthread_key_t
        >()
      ;
  }
} // namespace art::


namespace libart {
  void preinitSymbols() {
    using namespace ::facebook::museum::MUSEUM_VERSION::art;
    
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art5Locks13mutator_lock_E
        <MutatorMutex*
          >();
    
    
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art5Locks26thread_suspend_count_lock_E
        <Mutex*
          >();
    
    
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art7Runtime9instance_E
        <Runtime*
          >();
    
    
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art6Thread12resume_cond_E
        <ConditionVariable*
          >();
    
    
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art6Thread11is_started_E
        <bool
          >();
    
    
      ::facebook::museum::MUSEUM_VERSION::libart::lookups::lookup___ZN3art6Thread17pthread_key_self_E
        <pthread_key_t
          >();
    
  }
} // namespace libart

} } } // namespace facebook::museum::MUSEUM_VERSION
